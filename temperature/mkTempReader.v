//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Oct 29 15:07:57 UTC 2020
//
//
// Ports:
// Name                         I/O  size props
// get_temp                       O     8 reg
// CLK                            I     1 clock
// RST_N                          I     1 reset
// TEMP_I2C_SDA                  IO     1 inout
// TEMP_I2C_SCL                  IO     1 inout
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkTempReader(CLK,
		    RST_N,

		    .TEMP_I2C_SDA(temp_temp_tSDA$IO),
		    .TEMP_I2C_SCL(temp_temp_tSCL$IO),

		    get_temp);
  input  CLK;
  input  RST_N;

  inout  temp_temp_tSDA$IO;
  inout  temp_temp_tSCL$IO;

  // value method get_temp
  output [7 : 0] get_temp;

  // signals for module outputs
  wire [7 : 0] get_temp;

  // inlined wires
  wire main_start_wire$whas, main_state_set_pw$whas;

  // register cnt
  reg [31 : 0] cnt;
  wire [31 : 0] cnt$D_IN;
  wire cnt$EN;

  // register cur_temp
  reg [7 : 0] cur_temp;
  wire [7 : 0] cur_temp$D_IN;
  wire cur_temp$EN;

  // register main_start_reg
  reg main_start_reg;
  wire main_start_reg$D_IN, main_start_reg$EN;

  // register main_start_reg_1
  reg main_start_reg_1;
  wire main_start_reg_1$D_IN, main_start_reg_1$EN;

  // register main_state_can_overlap
  reg main_state_can_overlap;
  wire main_state_can_overlap$D_IN, main_state_can_overlap$EN;

  // register main_state_fired
  reg main_state_fired;
  wire main_state_fired$D_IN, main_state_fired$EN;

  // register main_state_mkFSMstate
  reg [3 : 0] main_state_mkFSMstate;
  reg [3 : 0] main_state_mkFSMstate$D_IN;
  wire main_state_mkFSMstate$EN;

  // register temp_temp_rAddress
  reg [7 : 0] temp_temp_rAddress;
  wire [7 : 0] temp_temp_rAddress$D_IN;
  wire temp_temp_rAddress$EN;

  // register temp_temp_rOutEn
  reg temp_temp_rOutEn;
  wire temp_temp_rOutEn$D_IN, temp_temp_rOutEn$EN;

  // register temp_temp_rSCL
  reg temp_temp_rSCL;
  wire temp_temp_rSCL$D_IN, temp_temp_rSCL$EN;

  // register temp_temp_rSDA
  reg temp_temp_rSDA;
  wire temp_temp_rSDA$D_IN, temp_temp_rSDA$EN;

  // register temp_temp_rSlaveAddr
  reg [6 : 0] temp_temp_rSlaveAddr;
  wire [6 : 0] temp_temp_rSlaveAddr$D_IN;
  wire temp_temp_rSlaveAddr$EN;

  // register temp_temp_rState
  reg temp_temp_rState;
  wire temp_temp_rState$D_IN, temp_temp_rState$EN;

  // register temp_temp_rWrite
  reg temp_temp_rWrite;
  wire temp_temp_rWrite$D_IN, temp_temp_rWrite$EN;

  // register temp_temp_rWriteData
  reg [7 : 0] temp_temp_rWriteData;
  wire [7 : 0] temp_temp_rWriteData$D_IN;
  wire temp_temp_rWriteData$EN;

  // register temp_temp_vrReadData_0
  reg temp_temp_vrReadData_0;
  wire temp_temp_vrReadData_0$D_IN, temp_temp_vrReadData_0$EN;

  // register temp_temp_vrReadData_1
  reg temp_temp_vrReadData_1;
  wire temp_temp_vrReadData_1$D_IN, temp_temp_vrReadData_1$EN;

  // register temp_temp_vrReadData_2
  reg temp_temp_vrReadData_2;
  wire temp_temp_vrReadData_2$D_IN, temp_temp_vrReadData_2$EN;

  // register temp_temp_vrReadData_3
  reg temp_temp_vrReadData_3;
  wire temp_temp_vrReadData_3$D_IN, temp_temp_vrReadData_3$EN;

  // register temp_temp_vrReadData_4
  reg temp_temp_vrReadData_4;
  wire temp_temp_vrReadData_4$D_IN, temp_temp_vrReadData_4$EN;

  // register temp_temp_vrReadData_5
  reg temp_temp_vrReadData_5;
  wire temp_temp_vrReadData_5$D_IN, temp_temp_vrReadData_5$EN;

  // register temp_temp_vrReadData_6
  reg temp_temp_vrReadData_6;
  wire temp_temp_vrReadData_6$D_IN, temp_temp_vrReadData_6$EN;

  // register temp_temp_vrReadData_7
  reg temp_temp_vrReadData_7;
  wire temp_temp_vrReadData_7$D_IN, temp_temp_vrReadData_7$EN;

  // ports of submodule temp_temp_fRequest
  wire [23 : 0] temp_temp_fRequest$D_IN, temp_temp_fRequest$D_OUT;
  wire temp_temp_fRequest$CLR,
       temp_temp_fRequest$DEQ,
       temp_temp_fRequest$EMPTY_N,
       temp_temp_fRequest$ENQ,
       temp_temp_fRequest$FULL_N;

  // ports of submodule temp_temp_fResponse
  wire [7 : 0] temp_temp_fResponse$D_IN, temp_temp_fResponse$D_OUT;
  wire temp_temp_fResponse$CLR,
       temp_temp_fResponse$DEQ,
       temp_temp_fResponse$EMPTY_N,
       temp_temp_fResponse$ENQ,
       temp_temp_fResponse$FULL_N;

  // ports of submodule temp_temp_rPlayIndex
  wire [9 : 0] temp_temp_rPlayIndex$DATA_A,
	       temp_temp_rPlayIndex$DATA_B,
	       temp_temp_rPlayIndex$DATA_C,
	       temp_temp_rPlayIndex$DATA_F,
	       temp_temp_rPlayIndex$Q_OUT;
  wire temp_temp_rPlayIndex$ADDA,
       temp_temp_rPlayIndex$ADDB,
       temp_temp_rPlayIndex$SETC,
       temp_temp_rPlayIndex$SETF;

  // ports of submodule temp_temp_rPrescaler
  wire [31 : 0] temp_temp_rPrescaler$DATA_A,
		temp_temp_rPrescaler$DATA_B,
		temp_temp_rPrescaler$DATA_C,
		temp_temp_rPrescaler$DATA_F,
		temp_temp_rPrescaler$Q_OUT;
  wire temp_temp_rPrescaler$ADDA,
       temp_temp_rPrescaler$ADDB,
       temp_temp_rPrescaler$SETC,
       temp_temp_rPrescaler$SETF;

  // ports of submodule temp_temp_tSCL
  wire temp_temp_tSCL$IO;

  // ports of submodule temp_temp_tSDA
  wire temp_temp_tSDA$IO, temp_temp_tSDA$O;

  // rule scheduling signals
  wire WILL_FIRE_RL_main_action_l19c27,
       WILL_FIRE_RL_main_action_l24c26,
       WILL_FIRE_RL_main_action_l25c13,
       WILL_FIRE_RL_main_action_l65c14,
       WILL_FIRE_RL_main_action_l70c18,
       WILL_FIRE_RL_main_fsm_start,
       WILL_FIRE_RL_temp_temp_done_read,
       WILL_FIRE_RL_temp_temp_done_write,
       WILL_FIRE_RL_temp_temp_running_read,
       WILL_FIRE_RL_temp_temp_running_write;

  // inputs to muxes for submodule ports
  wire [31 : 0] MUX_cnt$write_1__VAL_1;
  wire MUX_temp_temp_rOutEn$write_1__SEL_1,
       MUX_temp_temp_rOutEn$write_1__SEL_2,
       MUX_temp_temp_rOutEn$write_1__VAL_1,
       MUX_temp_temp_rOutEn$write_1__VAL_2,
       MUX_temp_temp_rSCL$write_1__VAL_1,
       MUX_temp_temp_rSCL$write_1__VAL_2,
       MUX_temp_temp_rSDA$write_1__VAL_1,
       MUX_temp_temp_rSDA$write_1__VAL_2,
       MUX_temp_temp_rState$write_1__SEL_1,
       MUX_temp_temp_rState$write_1__SEL_2;

  // remaining internal signals
  wire [116 : 0] _130549178157447095380771276656813203__q5,
		 _166153498389916941667817601160445959__q3,
		 _306783360__q1,
		 wRdData__h1600;
  wire [86 : 0] _121583396715528419856163987__q4,
		_154742503901866210315206599__q2,
		wWrData__h1604;
  wire [2 : 0] a0__h1589,
	       a1__h1588,
	       a2__h1587,
	       a3__h1586,
	       a4__h1585,
	       a5__h1584,
	       a6__h1583,
	       a7__h1582,
	       d0__h1598,
	       d1__h1597,
	       d2__h1596,
	       d3__h1595,
	       d4__h1594,
	       d5__h1593,
	       d6__h1592,
	       d7__h1591,
	       s0__h1580,
	       s1__h1579,
	       s2__h1578,
	       s3__h1577,
	       s4__h1576,
	       s5__h1575,
	       s6__h1574;
  wire _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108,
       main_abort_whas__35_AND_main_abort_wget__36_37_ETC___d188;

  // value method get_temp
  assign get_temp = cur_temp ;

  // submodule temp_temp_fRequest
  SizedFIFO #(.p1width(32'd24),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) temp_temp_fRequest(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(temp_temp_fRequest$D_IN),
						  .ENQ(temp_temp_fRequest$ENQ),
						  .DEQ(temp_temp_fRequest$DEQ),
						  .CLR(temp_temp_fRequest$CLR),
						  .D_OUT(temp_temp_fRequest$D_OUT),
						  .FULL_N(temp_temp_fRequest$FULL_N),
						  .EMPTY_N(temp_temp_fRequest$EMPTY_N));

  // submodule temp_temp_fResponse
  SizedFIFO #(.p1width(32'd8),
	      .p2depth(32'd16),
	      .p3cntr_width(32'd4),
	      .guarded(32'd1)) temp_temp_fResponse(.RST(RST_N),
						   .CLK(CLK),
						   .D_IN(temp_temp_fResponse$D_IN),
						   .ENQ(temp_temp_fResponse$ENQ),
						   .DEQ(temp_temp_fResponse$DEQ),
						   .CLR(temp_temp_fResponse$CLR),
						   .D_OUT(temp_temp_fResponse$D_OUT),
						   .FULL_N(temp_temp_fResponse$FULL_N),
						   .EMPTY_N(temp_temp_fResponse$EMPTY_N));

  // submodule temp_temp_rPlayIndex
  Counter #(.width(32'd10), .init(10'd0)) temp_temp_rPlayIndex(.CLK(CLK),
							       .RST(RST_N),
							       .DATA_A(temp_temp_rPlayIndex$DATA_A),
							       .DATA_B(temp_temp_rPlayIndex$DATA_B),
							       .DATA_C(temp_temp_rPlayIndex$DATA_C),
							       .DATA_F(temp_temp_rPlayIndex$DATA_F),
							       .ADDA(temp_temp_rPlayIndex$ADDA),
							       .ADDB(temp_temp_rPlayIndex$ADDB),
							       .SETC(temp_temp_rPlayIndex$SETC),
							       .SETF(temp_temp_rPlayIndex$SETF),
							       .Q_OUT(temp_temp_rPlayIndex$Q_OUT));

  // submodule temp_temp_rPrescaler
  Counter #(.width(32'd32), .init(32'd125)) temp_temp_rPrescaler(.CLK(CLK),
								 .RST(RST_N),
								 .DATA_A(temp_temp_rPrescaler$DATA_A),
								 .DATA_B(temp_temp_rPrescaler$DATA_B),
								 .DATA_C(temp_temp_rPrescaler$DATA_C),
								 .DATA_F(temp_temp_rPrescaler$DATA_F),
								 .ADDA(temp_temp_rPrescaler$ADDA),
								 .ADDB(temp_temp_rPrescaler$ADDB),
								 .SETC(temp_temp_rPrescaler$SETC),
								 .SETF(temp_temp_rPrescaler$SETF),
								 .Q_OUT(temp_temp_rPrescaler$Q_OUT));

  // submodule temp_temp_tSCL
  TriState #(.width(32'd1)) temp_temp_tSCL(.I(temp_temp_rSCL),
					   .OE(1'd1),
					   .O(),
					   .IO(temp_temp_tSCL$IO));

  // submodule temp_temp_tSDA
  TriState #(.width(32'd1)) temp_temp_tSDA(.I(temp_temp_rSDA),
					   .OE(temp_temp_rOutEn),
					   .O(temp_temp_tSDA$O),
					   .IO(temp_temp_tSDA$IO));

  // rule RL_temp_temp_running_write
  assign WILL_FIRE_RL_temp_temp_running_write =
	     temp_temp_rState && temp_temp_rWrite &&
	     temp_temp_rPrescaler$Q_OUT == 32'd0 &&
	     temp_temp_rPlayIndex$Q_OUT != 10'd0 ;

  // rule RL_temp_temp_running_read
  assign WILL_FIRE_RL_temp_temp_running_read =
	     temp_temp_rState && !temp_temp_rWrite &&
	     temp_temp_rPrescaler$Q_OUT == 32'd0 &&
	     temp_temp_rPlayIndex$Q_OUT != 10'd0 ;

  // rule RL_temp_temp_done_write
  assign WILL_FIRE_RL_temp_temp_done_write =
	     temp_temp_rState && temp_temp_rWrite &&
	     temp_temp_rPrescaler$Q_OUT == 32'd0 &&
	     temp_temp_rPlayIndex$Q_OUT == 10'd0 ;

  // rule RL_temp_temp_done_read
  assign WILL_FIRE_RL_temp_temp_done_read =
	     temp_temp_fResponse$FULL_N && temp_temp_rState &&
	     !temp_temp_rWrite &&
	     temp_temp_rPrescaler$Q_OUT == 32'd0 &&
	     temp_temp_rPlayIndex$Q_OUT == 10'd0 ;

  // rule RL_main_action_l19c27
  assign WILL_FIRE_RL_main_action_l19c27 =
	     temp_temp_fRequest$FULL_N && main_state_mkFSMstate == 4'd1 ;

  // rule RL_main_action_l24c26
  assign WILL_FIRE_RL_main_action_l24c26 =
	     temp_temp_fRequest$FULL_N &&
	     (main_state_mkFSMstate == 4'd2 ||
	      main_state_mkFSMstate == 4'd6) ;

  // rule RL_main_action_l25c13
  assign WILL_FIRE_RL_main_action_l25c13 =
	     temp_temp_fResponse$EMPTY_N && main_state_mkFSMstate == 4'd3 ;

  // rule RL_main_action_l70c18
  assign WILL_FIRE_RL_main_action_l70c18 =
	     cnt == 32'd0 && main_state_mkFSMstate == 4'd5 ;

  // rule RL_main_fsm_start
  assign WILL_FIRE_RL_main_fsm_start =
	     main_abort_whas__35_AND_main_abort_wget__36_37_ETC___d188 &&
	     main_start_reg ;

  // rule RL_main_action_l65c14
  assign WILL_FIRE_RL_main_action_l65c14 =
	     cnt == 32'd0 && main_start_wire$whas &&
	     main_state_mkFSMstate == 4'd0 ;

  // inputs to muxes for submodule ports
  assign MUX_temp_temp_rOutEn$write_1__SEL_1 =
	     WILL_FIRE_RL_temp_temp_done_write ||
	     WILL_FIRE_RL_temp_temp_running_write ;
  assign MUX_temp_temp_rOutEn$write_1__SEL_2 =
	     WILL_FIRE_RL_temp_temp_done_read ||
	     WILL_FIRE_RL_temp_temp_running_read ;
  assign MUX_temp_temp_rState$write_1__SEL_1 =
	     WILL_FIRE_RL_temp_temp_done_read ||
	     WILL_FIRE_RL_temp_temp_done_write ;
  assign MUX_temp_temp_rState$write_1__SEL_2 =
	     temp_temp_fRequest$EMPTY_N && !temp_temp_rState ;
  assign MUX_cnt$write_1__VAL_1 = cnt - 32'd1 ;
  assign MUX_temp_temp_rOutEn$write_1__VAL_1 =
	     _154742503901866210315206599__q2[temp_temp_rPlayIndex$Q_OUT[6:0]] ;
  assign MUX_temp_temp_rOutEn$write_1__VAL_2 =
	     _166153498389916941667817601160445959__q3[temp_temp_rPlayIndex$Q_OUT[6:0]] ;
  assign MUX_temp_temp_rSCL$write_1__VAL_1 =
	     _121583396715528419856163987__q4[temp_temp_rPlayIndex$Q_OUT[6:0]] ;
  assign MUX_temp_temp_rSCL$write_1__VAL_2 =
	     _130549178157447095380771276656813203__q5[temp_temp_rPlayIndex$Q_OUT[6:0]] ;
  assign MUX_temp_temp_rSDA$write_1__VAL_1 =
	     wRdData__h1600[temp_temp_rPlayIndex$Q_OUT[6:0]] ;
  assign MUX_temp_temp_rSDA$write_1__VAL_2 =
	     wWrData__h1604[temp_temp_rPlayIndex$Q_OUT[6:0]] ;

  // inlined wires
  assign main_start_wire$whas =
	     WILL_FIRE_RL_main_fsm_start ||
	     main_start_reg_1 && !main_state_fired ;
  assign main_state_set_pw$whas =
	     WILL_FIRE_RL_main_action_l70c18 ||
	     main_state_mkFSMstate == 4'd4 ||
	     WILL_FIRE_RL_main_action_l25c13 ||
	     WILL_FIRE_RL_main_action_l24c26 ||
	     WILL_FIRE_RL_main_action_l19c27 ||
	     WILL_FIRE_RL_main_action_l65c14 ;

  // register cnt
  assign cnt$D_IN = (cnt != 32'd0) ? MUX_cnt$write_1__VAL_1 : 32'd50000000 ;
  assign cnt$EN =
	     cnt != 32'd0 || cnt == 32'd0 && main_state_mkFSMstate == 4'd4 ;

  // register cur_temp
  assign cur_temp$D_IN = temp_temp_fResponse$D_OUT ;
  assign cur_temp$EN = WILL_FIRE_RL_main_action_l25c13 ;

  // register main_start_reg
  assign main_start_reg$D_IN = !WILL_FIRE_RL_main_fsm_start ;
  assign main_start_reg$EN =
	     WILL_FIRE_RL_main_fsm_start ||
	     main_abort_whas__35_AND_main_abort_wget__36_37_ETC___d188 &&
	     !main_start_reg ;

  // register main_start_reg_1
  assign main_start_reg_1$D_IN = main_start_wire$whas ;
  assign main_start_reg_1$EN = 1'd1 ;

  // register main_state_can_overlap
  assign main_state_can_overlap$D_IN =
	     main_state_set_pw$whas || main_state_can_overlap ;
  assign main_state_can_overlap$EN = 1'd1 ;

  // register main_state_fired
  assign main_state_fired$D_IN = main_state_set_pw$whas ;
  assign main_state_fired$EN = 1'd1 ;

  // register main_state_mkFSMstate
  always@(WILL_FIRE_RL_main_action_l65c14 or
	  WILL_FIRE_RL_main_action_l19c27 or
	  WILL_FIRE_RL_main_action_l24c26 or
	  WILL_FIRE_RL_main_action_l25c13 or
	  main_state_mkFSMstate or WILL_FIRE_RL_main_action_l70c18)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_main_action_l65c14: main_state_mkFSMstate$D_IN = 4'd1;
      WILL_FIRE_RL_main_action_l19c27: main_state_mkFSMstate$D_IN = 4'd2;
      WILL_FIRE_RL_main_action_l24c26: main_state_mkFSMstate$D_IN = 4'd3;
      WILL_FIRE_RL_main_action_l25c13: main_state_mkFSMstate$D_IN = 4'd4;
      main_state_mkFSMstate == 4'd4: main_state_mkFSMstate$D_IN = 4'd5;
      WILL_FIRE_RL_main_action_l70c18: main_state_mkFSMstate$D_IN = 4'd6;
      default: main_state_mkFSMstate$D_IN = 4'b1010 /* unspecified value */ ;
    endcase
  end
  assign main_state_mkFSMstate$EN =
	     WILL_FIRE_RL_main_action_l65c14 ||
	     WILL_FIRE_RL_main_action_l19c27 ||
	     WILL_FIRE_RL_main_action_l24c26 ||
	     WILL_FIRE_RL_main_action_l25c13 ||
	     main_state_mkFSMstate == 4'd4 ||
	     WILL_FIRE_RL_main_action_l70c18 ;

  // register temp_temp_rAddress
  assign temp_temp_rAddress$D_IN = temp_temp_fRequest$D_OUT[15:8] ;
  assign temp_temp_rAddress$EN = MUX_temp_temp_rState$write_1__SEL_2 ;

  // register temp_temp_rOutEn
  assign temp_temp_rOutEn$D_IN =
	     MUX_temp_temp_rOutEn$write_1__SEL_1 ?
	       MUX_temp_temp_rOutEn$write_1__VAL_1 :
	       MUX_temp_temp_rOutEn$write_1__VAL_2 ;
  assign temp_temp_rOutEn$EN =
	     WILL_FIRE_RL_temp_temp_done_write ||
	     WILL_FIRE_RL_temp_temp_running_write ||
	     WILL_FIRE_RL_temp_temp_done_read ||
	     WILL_FIRE_RL_temp_temp_running_read ;

  // register temp_temp_rSCL
  assign temp_temp_rSCL$D_IN =
	     MUX_temp_temp_rOutEn$write_1__SEL_1 ?
	       MUX_temp_temp_rSCL$write_1__VAL_1 :
	       MUX_temp_temp_rSCL$write_1__VAL_2 ;
  assign temp_temp_rSCL$EN =
	     WILL_FIRE_RL_temp_temp_done_write ||
	     WILL_FIRE_RL_temp_temp_running_write ||
	     WILL_FIRE_RL_temp_temp_done_read ||
	     WILL_FIRE_RL_temp_temp_running_read ;

  // register temp_temp_rSDA
  assign temp_temp_rSDA$D_IN =
	     MUX_temp_temp_rOutEn$write_1__SEL_2 ?
	       MUX_temp_temp_rSDA$write_1__VAL_1 :
	       MUX_temp_temp_rSDA$write_1__VAL_2 ;
  assign temp_temp_rSDA$EN =
	     WILL_FIRE_RL_temp_temp_done_read ||
	     WILL_FIRE_RL_temp_temp_running_read ||
	     WILL_FIRE_RL_temp_temp_done_write ||
	     WILL_FIRE_RL_temp_temp_running_write ;

  // register temp_temp_rSlaveAddr
  assign temp_temp_rSlaveAddr$D_IN = temp_temp_fRequest$D_OUT[22:16] ;
  assign temp_temp_rSlaveAddr$EN = MUX_temp_temp_rState$write_1__SEL_2 ;

  // register temp_temp_rState
  assign temp_temp_rState$D_IN = !MUX_temp_temp_rState$write_1__SEL_1 ;
  assign temp_temp_rState$EN =
	     WILL_FIRE_RL_temp_temp_done_read ||
	     WILL_FIRE_RL_temp_temp_done_write ||
	     temp_temp_fRequest$EMPTY_N && !temp_temp_rState ;

  // register temp_temp_rWrite
  assign temp_temp_rWrite$D_IN = temp_temp_fRequest$D_OUT[23] ;
  assign temp_temp_rWrite$EN = MUX_temp_temp_rState$write_1__SEL_2 ;

  // register temp_temp_rWriteData
  assign temp_temp_rWriteData$D_IN = temp_temp_fRequest$D_OUT[7:0] ;
  assign temp_temp_rWriteData$EN = MUX_temp_temp_rState$write_1__SEL_2 ;

  // register temp_temp_vrReadData_0
  assign temp_temp_vrReadData_0$D_IN = temp_temp_tSDA$O ;
  assign temp_temp_vrReadData_0$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_1
  assign temp_temp_vrReadData_1$D_IN = temp_temp_vrReadData_0 ;
  assign temp_temp_vrReadData_1$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_2
  assign temp_temp_vrReadData_2$D_IN = temp_temp_vrReadData_1 ;
  assign temp_temp_vrReadData_2$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_3
  assign temp_temp_vrReadData_3$D_IN = temp_temp_vrReadData_2 ;
  assign temp_temp_vrReadData_3$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_4
  assign temp_temp_vrReadData_4$D_IN = temp_temp_vrReadData_3 ;
  assign temp_temp_vrReadData_4$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_5
  assign temp_temp_vrReadData_5$D_IN = temp_temp_vrReadData_4 ;
  assign temp_temp_vrReadData_5$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_6
  assign temp_temp_vrReadData_6$D_IN = temp_temp_vrReadData_5 ;
  assign temp_temp_vrReadData_6$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // register temp_temp_vrReadData_7
  assign temp_temp_vrReadData_7$D_IN = temp_temp_vrReadData_6 ;
  assign temp_temp_vrReadData_7$EN =
	     WILL_FIRE_RL_temp_temp_running_read &&
	     _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 ;

  // submodule temp_temp_fRequest
  assign temp_temp_fRequest$D_IN =
	     WILL_FIRE_RL_main_action_l24c26 ? 24'd1835264 : 24'd10226196 ;
  assign temp_temp_fRequest$ENQ =
	     WILL_FIRE_RL_main_action_l24c26 ||
	     WILL_FIRE_RL_main_action_l19c27 ;
  assign temp_temp_fRequest$DEQ = MUX_temp_temp_rState$write_1__SEL_2 ;
  assign temp_temp_fRequest$CLR = 1'b0 ;

  // submodule temp_temp_fResponse
  assign temp_temp_fResponse$D_IN =
	     { temp_temp_vrReadData_7,
	       temp_temp_vrReadData_6,
	       temp_temp_vrReadData_5,
	       temp_temp_vrReadData_4,
	       temp_temp_vrReadData_3,
	       temp_temp_vrReadData_2,
	       temp_temp_vrReadData_1,
	       temp_temp_vrReadData_0 } ;
  assign temp_temp_fResponse$ENQ = WILL_FIRE_RL_temp_temp_done_read ;
  assign temp_temp_fResponse$DEQ = WILL_FIRE_RL_main_action_l25c13 ;
  assign temp_temp_fResponse$CLR = 1'b0 ;

  // submodule temp_temp_rPlayIndex
  assign temp_temp_rPlayIndex$DATA_A = 10'h0 ;
  assign temp_temp_rPlayIndex$DATA_B = 10'd1023 ;
  assign temp_temp_rPlayIndex$DATA_C = 10'h0 ;
  assign temp_temp_rPlayIndex$DATA_F =
	     temp_temp_fRequest$D_OUT[23] ? 10'd86 : 10'd116 ;
  assign temp_temp_rPlayIndex$ADDA = 1'b0 ;
  assign temp_temp_rPlayIndex$ADDB =
	     WILL_FIRE_RL_temp_temp_done_write ||
	     WILL_FIRE_RL_temp_temp_running_read ||
	     WILL_FIRE_RL_temp_temp_running_write ;
  assign temp_temp_rPlayIndex$SETC = 1'b0 ;
  assign temp_temp_rPlayIndex$SETF = MUX_temp_temp_rState$write_1__SEL_2 ;

  // submodule temp_temp_rPrescaler
  assign temp_temp_rPrescaler$DATA_A = 32'h0 ;
  assign temp_temp_rPrescaler$DATA_B = 32'hFFFFFFFF ;
  assign temp_temp_rPrescaler$DATA_C = 32'h0 ;
  assign temp_temp_rPrescaler$DATA_F = 32'd125 ;
  assign temp_temp_rPrescaler$ADDA = 1'b0 ;
  assign temp_temp_rPrescaler$ADDB = temp_temp_rPrescaler$Q_OUT != 32'd0 ;
  assign temp_temp_rPrescaler$SETC = 1'b0 ;
  assign temp_temp_rPrescaler$SETF = temp_temp_rPrescaler$Q_OUT == 32'd0 ;

  // remaining internal signals
  assign _121583396715528419856163987__q4 = 87'h6492492492492492492493 ;
  assign _130549178157447095380771276656813203__q5 =
	     117'h192492492492492E92492492492493 ;
  assign _154742503901866210315206599__q2 = 87'h7FFFFFF1FFFFFE3FFFFFC7 ;
  assign _166153498389916941667817601160445959__q3 =
	     117'h1FFFFFFC7FFFFF8FFFFFFE00000007 ;
  assign _306783360_BIT_temp_temp_rPlayIndex_value__8_BI_ETC___d108 =
	     _306783360__q1[temp_temp_rPlayIndex$Q_OUT[6:0]] ;
  assign _306783360__q1 = 117'd306783360 ;
  assign a0__h1589 = {3{temp_temp_rAddress[0]}} ;
  assign a1__h1588 = {3{temp_temp_rAddress[1]}} ;
  assign a2__h1587 = {3{temp_temp_rAddress[2]}} ;
  assign a3__h1586 = {3{temp_temp_rAddress[3]}} ;
  assign a4__h1585 = {3{temp_temp_rAddress[4]}} ;
  assign a5__h1584 = {3{temp_temp_rAddress[5]}} ;
  assign a6__h1583 = {3{temp_temp_rAddress[6]}} ;
  assign a7__h1582 = {3{temp_temp_rAddress[7]}} ;
  assign d0__h1598 = {3{temp_temp_rWriteData[0]}} ;
  assign d1__h1597 = {3{temp_temp_rWriteData[1]}} ;
  assign d2__h1596 = {3{temp_temp_rWriteData[2]}} ;
  assign d3__h1595 = {3{temp_temp_rWriteData[3]}} ;
  assign d4__h1594 = {3{temp_temp_rWriteData[4]}} ;
  assign d5__h1593 = {3{temp_temp_rWriteData[5]}} ;
  assign d6__h1592 = {3{temp_temp_rWriteData[6]}} ;
  assign d7__h1591 = {3{temp_temp_rWriteData[7]}} ;
  assign main_abort_whas__35_AND_main_abort_wget__36_37_ETC___d188 =
	     main_state_mkFSMstate == 4'd0 &&
	     (!main_start_reg_1 || main_state_fired) ;
  assign s0__h1580 = {3{temp_temp_rSlaveAddr[0]}} ;
  assign s1__h1579 = {3{temp_temp_rSlaveAddr[1]}} ;
  assign s2__h1578 = {3{temp_temp_rSlaveAddr[2]}} ;
  assign s3__h1577 = {3{temp_temp_rSlaveAddr[3]}} ;
  assign s4__h1576 = {3{temp_temp_rSlaveAddr[4]}} ;
  assign s5__h1575 = {3{temp_temp_rSlaveAddr[5]}} ;
  assign s6__h1574 = {3{temp_temp_rSlaveAddr[6]}} ;
  assign wRdData__h1600 =
	     { 3'b100,
	       s6__h1574,
	       s5__h1575,
	       s4__h1576,
	       s3__h1577,
	       s2__h1578,
	       s1__h1579,
	       s0__h1580,
	       6'd0,
	       a7__h1582,
	       a6__h1583,
	       a5__h1584,
	       a4__h1585,
	       a3__h1586,
	       a2__h1587,
	       a1__h1588,
	       a0__h1589,
	       6'd6,
	       s6__h1574,
	       s5__h1575,
	       s4__h1576,
	       s3__h1577,
	       s2__h1578,
	       s1__h1579,
	       s0__h1580,
	       36'hE00000001 } ;
  assign wWrData__h1604 =
	     { 3'b100,
	       s6__h1574,
	       s5__h1575,
	       s4__h1576,
	       s3__h1577,
	       s2__h1578,
	       s1__h1579,
	       s0__h1580,
	       6'd0,
	       a7__h1582,
	       a6__h1583,
	       a5__h1584,
	       a4__h1585,
	       a3__h1586,
	       a2__h1587,
	       a1__h1588,
	       a0__h1589,
	       3'b0,
	       d7__h1591,
	       d6__h1592,
	       d5__h1593,
	       d4__h1594,
	       d3__h1595,
	       d2__h1596,
	       d1__h1597,
	       d0__h1598,
	       6'd1 } ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        cnt <= `BSV_ASSIGNMENT_DELAY 32'd50000000;
	cur_temp <= `BSV_ASSIGNMENT_DELAY 8'd0;
	main_start_reg <= `BSV_ASSIGNMENT_DELAY 1'd0;
	main_start_reg_1 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	main_state_can_overlap <= `BSV_ASSIGNMENT_DELAY 1'd1;
	main_state_fired <= `BSV_ASSIGNMENT_DELAY 1'd0;
	main_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY 4'd0;
	temp_temp_rOutEn <= `BSV_ASSIGNMENT_DELAY 1'd1;
	temp_temp_rSCL <= `BSV_ASSIGNMENT_DELAY 1'd1;
	temp_temp_rSDA <= `BSV_ASSIGNMENT_DELAY 1'd1;
	temp_temp_rState <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (cnt$EN) cnt <= `BSV_ASSIGNMENT_DELAY cnt$D_IN;
	if (cur_temp$EN) cur_temp <= `BSV_ASSIGNMENT_DELAY cur_temp$D_IN;
	if (main_start_reg$EN)
	  main_start_reg <= `BSV_ASSIGNMENT_DELAY main_start_reg$D_IN;
	if (main_start_reg_1$EN)
	  main_start_reg_1 <= `BSV_ASSIGNMENT_DELAY main_start_reg_1$D_IN;
	if (main_state_can_overlap$EN)
	  main_state_can_overlap <= `BSV_ASSIGNMENT_DELAY
	      main_state_can_overlap$D_IN;
	if (main_state_fired$EN)
	  main_state_fired <= `BSV_ASSIGNMENT_DELAY main_state_fired$D_IN;
	if (main_state_mkFSMstate$EN)
	  main_state_mkFSMstate <= `BSV_ASSIGNMENT_DELAY
	      main_state_mkFSMstate$D_IN;
	if (temp_temp_rOutEn$EN)
	  temp_temp_rOutEn <= `BSV_ASSIGNMENT_DELAY temp_temp_rOutEn$D_IN;
	if (temp_temp_rSCL$EN)
	  temp_temp_rSCL <= `BSV_ASSIGNMENT_DELAY temp_temp_rSCL$D_IN;
	if (temp_temp_rSDA$EN)
	  temp_temp_rSDA <= `BSV_ASSIGNMENT_DELAY temp_temp_rSDA$D_IN;
	if (temp_temp_rState$EN)
	  temp_temp_rState <= `BSV_ASSIGNMENT_DELAY temp_temp_rState$D_IN;
      end
    if (temp_temp_rAddress$EN)
      temp_temp_rAddress <= `BSV_ASSIGNMENT_DELAY temp_temp_rAddress$D_IN;
    if (temp_temp_rSlaveAddr$EN)
      temp_temp_rSlaveAddr <= `BSV_ASSIGNMENT_DELAY temp_temp_rSlaveAddr$D_IN;
    if (temp_temp_rWrite$EN)
      temp_temp_rWrite <= `BSV_ASSIGNMENT_DELAY temp_temp_rWrite$D_IN;
    if (temp_temp_rWriteData$EN)
      temp_temp_rWriteData <= `BSV_ASSIGNMENT_DELAY temp_temp_rWriteData$D_IN;
    if (temp_temp_vrReadData_0$EN)
      temp_temp_vrReadData_0 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_0$D_IN;
    if (temp_temp_vrReadData_1$EN)
      temp_temp_vrReadData_1 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_1$D_IN;
    if (temp_temp_vrReadData_2$EN)
      temp_temp_vrReadData_2 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_2$D_IN;
    if (temp_temp_vrReadData_3$EN)
      temp_temp_vrReadData_3 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_3$D_IN;
    if (temp_temp_vrReadData_4$EN)
      temp_temp_vrReadData_4 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_4$D_IN;
    if (temp_temp_vrReadData_5$EN)
      temp_temp_vrReadData_5 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_5$D_IN;
    if (temp_temp_vrReadData_6$EN)
      temp_temp_vrReadData_6 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_6$D_IN;
    if (temp_temp_vrReadData_7$EN)
      temp_temp_vrReadData_7 <= `BSV_ASSIGNMENT_DELAY
	  temp_temp_vrReadData_7$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    cnt = 32'hAAAAAAAA;
    cur_temp = 8'hAA;
    main_start_reg = 1'h0;
    main_start_reg_1 = 1'h0;
    main_state_can_overlap = 1'h0;
    main_state_fired = 1'h0;
    main_state_mkFSMstate = 4'hA;
    temp_temp_rAddress = 8'hAA;
    temp_temp_rOutEn = 1'h0;
    temp_temp_rSCL = 1'h0;
    temp_temp_rSDA = 1'h0;
    temp_temp_rSlaveAddr = 7'h2A;
    temp_temp_rState = 1'h0;
    temp_temp_rWrite = 1'h0;
    temp_temp_rWriteData = 8'hAA;
    temp_temp_vrReadData_0 = 1'h0;
    temp_temp_vrReadData_1 = 1'h0;
    temp_temp_vrReadData_2 = 1'h0;
    temp_temp_vrReadData_3 = 1'h0;
    temp_temp_vrReadData_4 = 1'h0;
    temp_temp_vrReadData_5 = 1'h0;
    temp_temp_vrReadData_6 = 1'h0;
    temp_temp_vrReadData_7 = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_main_action_l19c27 &&
	  (WILL_FIRE_RL_main_action_l24c26 ||
	   WILL_FIRE_RL_main_action_l25c13 ||
	   main_state_mkFSMstate == 4'd4 ||
	   WILL_FIRE_RL_main_action_l70c18))
	$display("Error: \"DE10-I2C-devices/Temp.bsv\", line 19, column 27: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_main_action_l19c27] and\n  [RL_main_action_l24c26, RL_main_action_l25c13, RL_main_action_l69c15,\n  RL_main_action_l70c18] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_main_action_l24c26 &&
	  (WILL_FIRE_RL_main_action_l25c13 || main_state_mkFSMstate == 4'd4 ||
	   WILL_FIRE_RL_main_action_l70c18))
	$display("Error: \"DE10-I2C-devices/Temp.bsv\", line 24, column 26: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_main_action_l24c26] and\n  [RL_main_action_l25c13, RL_main_action_l69c15, RL_main_action_l70c18] )\n  fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_main_action_l25c13 &&
	  (main_state_mkFSMstate == 4'd4 || WILL_FIRE_RL_main_action_l70c18))
	$display("Error: \"DE10-I2C-devices/Temp.bsv\", line 25, column 13: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_main_action_l25c13] and\n  [RL_main_action_l69c15, RL_main_action_l70c18] ) fired in the same clock\n  cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (main_state_mkFSMstate == 4'd4 && WILL_FIRE_RL_main_action_l70c18)
	$display("Error: \"DE10-I2C-devices/Temp.bsv\", line 69, column 15: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_main_action_l69c15] and\n  [RL_main_action_l70c18] ) fired in the same clock cycle.\n");
    if (RST_N != `BSV_RESET_VALUE)
      if (WILL_FIRE_RL_main_action_l65c14 &&
	  (WILL_FIRE_RL_main_action_l19c27 ||
	   WILL_FIRE_RL_main_action_l24c26 ||
	   WILL_FIRE_RL_main_action_l25c13 ||
	   main_state_mkFSMstate == 4'd4 ||
	   WILL_FIRE_RL_main_action_l70c18))
	$display("Error: \"DE10-I2C-devices/Temp.bsv\", line 65, column 14: (R0001)\n  Mutually exclusive rules (from the ME sets [RL_main_action_l65c14] and\n  [RL_main_action_l19c27, RL_main_action_l24c26, RL_main_action_l25c13,\n  RL_main_action_l69c15, RL_main_action_l70c18] ) fired in the same clock\n  cycle.\n");
  end
  // synopsys translate_on
endmodule  // mkTempReader

